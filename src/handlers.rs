use axum::{extract::{State, Multipart, Path, ConnectInfo, Query, DefaultBodyLimit, Form}, http::{StatusCode, HeaderMap, header::{CACHE_CONTROL, CONTENT_TYPE}, HeaderValue}, response::{IntoResponse, Response}, routing::{get, post, delete}, Json, Router, middleware::{self, Next}};
use std::{net::SocketAddr as ClientAddr, borrow::Cow, collections::HashMap};
use tokio::{fs, io::AsyncWriteExt};
use tokio_util::io::ReaderStream;
use axum::body::Body;
use serde::{Serialize, Deserialize};
use crate::util::{json_error, real_client_ip, is_forbidden_extension, make_storage_name, now_secs, ttl_to_duration, qualify_path, MAX_FILE_BYTES, PROD_HOST};
use crate::state::{AppState, FileMeta, ReportRecord, cleanup_expired, reload_metadata_if_changed, verify_user_entries, verify_user_entries_with_report, spawn_integrity_check, ReconcileReport};

// Response structs
#[derive(Serialize)] pub struct UploadResponse { pub files: Vec<String> }
#[derive(Serialize)] pub struct ListResponse { pub files: Vec<String>, pub metas: Vec<FileMetaEntry>, pub reconcile: Option<ReconcileReport> }
#[derive(Serialize)] pub struct FileMetaEntry { pub file: String, pub expires: u64 }

#[derive(Deserialize)] pub struct ReportForm { pub file: String, pub reason: String, pub details: Option<String> }
#[derive(Deserialize)] pub struct SimpleQuery { pub m: Option<String> }
#[derive(Deserialize)] pub struct SimpleDeleteForm { pub f: String }
#[derive(Deserialize)] pub struct DeleteQuery { pub f: String }

// Upload handler
#[axum::debug_handler]
pub async fn upload_handler(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, mut multipart: Multipart) -> Response {
    let client_ip = real_client_ip(&headers, &addr);
    let _permit = match state.upload_sem.clone().try_acquire_owned() { Ok(p)=>p, Err(_)=> return json_error(StatusCode::SERVICE_UNAVAILABLE, "upload_busy", "too many concurrent uploads") };
    if let Err(_)=fs::create_dir_all(&*state.upload_dir).await { return json_error(StatusCode::INTERNAL_SERVER_ERROR, "fs_error", "create directory failed"); }
    let mut saved_files=Vec::new(); let mut ttl_choice=None; let mut any_aborted=false;
    while let Ok(Some(field)) = multipart.next_field().await { let name_opt=field.name().map(|s| s.to_string()); if name_opt.as_deref()==Some("ttl") { if let Ok(v)=field.text().await { ttl_choice=Some(v); } continue; } let mut field=field; if let Some(filename)=field.file_name() { if is_forbidden_extension(filename) { return json_error(StatusCode::BAD_REQUEST, "forbidden_type", "file type not allowed"); } let storage_name=make_storage_name(Some(filename)); let path=state.upload_dir.join(&storage_name); let mut file=match fs::File::create(&path).await { Ok(f)=>f, Err(_)=> return json_error(StatusCode::INTERNAL_SERVER_ERROR, "fs_error", "failed to create file") }; let mut written=0u64; let mut aborted=false; loop { match field.chunk().await { Ok(opt) => { if let Some(chunk)=opt { written += chunk.len() as u64; if written > MAX_FILE_BYTES { let _=fs::remove_file(&path).await; let mut resp=json_error(StatusCode::PAYLOAD_TOO_LARGE, "file_too_large", "file exceeds 500MB limit"); resp.headers_mut().insert("X-File-Too-Large", "1".parse().unwrap()); return resp; } if let Err(_)=file.write_all(&chunk).await { return json_error(StatusCode::INTERNAL_SERVER_ERROR, "fs_error", "failed writing chunk"); } } else { break; } }, Err(_)=>{ aborted=true; any_aborted=true; break; } } } if aborted || written==0 { let _=fs::remove_file(&path).await; continue; } let ttl_code=ttl_choice.clone().unwrap_or_else(||"3d".to_string()); let expires=now_secs()+ttl_to_duration(&ttl_code).as_secs(); { let mut owners=state.owners.write().await; owners.insert(storage_name.clone(), FileMeta{ owner: client_ip.clone(), expires }); } state.persist_owners().await; saved_files.push(format!("f/{}", storage_name)); } }
    if saved_files.is_empty() { if any_aborted { return json_error(StatusCode::BAD_REQUEST, "upload_aborted", "upload aborted"); } return json_error(StatusCode::BAD_REQUEST, "no_files", "no files uploaded"); }
    spawn_integrity_check(state.clone());
    println!("upload from {}: {} file(s): {}", client_ip, saved_files.len(), saved_files.join(","));
    let out_files: Vec<String> = saved_files.iter().map(|f| qualify_path(&state, f)).collect();
    Json(UploadResponse { files: out_files }).into_response()
}

pub async fn list_handler(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap) -> Response {
    reload_metadata_if_changed(&state).await; let client_ip=real_client_ip(&headers, &addr); let reconcile_report=verify_user_entries_with_report(&state, &client_ip).await; cleanup_expired(&state).await; crate::state::check_storage_integrity(&state).await; let owners=state.owners.read().await; let mut files: Vec<(String,u64)>=owners.iter().filter_map(|(f,m)| if m.owner==client_ip { Some((f.clone(), m.expires)) } else { None }).collect(); files.sort_by(|a,b| a.0.cmp(&b.0)); let only_names: Vec<String>=files.iter().map(|(n,_)| qualify_path(&state, &format!("f/{}", n))).collect(); let metas: Vec<FileMetaEntry>=files.into_iter().map(|(n,e)| FileMetaEntry{ file: qualify_path(&state, &format!("f/{}", n)), expires: e }).collect(); let body=Json(ListResponse{ files: only_names, metas, reconcile: reconcile_report }); let mut resp=body.into_response(); resp.headers_mut().insert(CACHE_CONTROL, "no-store".parse().unwrap()); resp }

#[axum::debug_handler]
pub async fn fetch_file_handler(State(state): State<AppState>, Path(file): Path<String>) -> Response { if file.contains('/') { return (StatusCode::BAD_REQUEST, "bad file").into_response(); } cleanup_expired(&state).await; let expired={ let owners=state.owners.read().await; owners.get(&file).map(|m| m.expires <= now_secs()).unwrap_or(true) }; if expired { return (StatusCode::NOT_FOUND, "not found").into_response(); } let file_path=state.upload_dir.join(&file); if !file_path.exists() { return (StatusCode::NOT_FOUND, "not found").into_response(); } match fs::File::open(&file_path).await { Ok(file)=>{ let stream=ReaderStream::new(file); let body=Body::from_stream(stream); let mime=mime_guess::from_path(&file_path).first_or_octet_stream(); let mut headers=HeaderMap::new(); headers.insert(axum::http::header::CONTENT_TYPE, mime.as_ref().parse().unwrap()); (headers, body).into_response() }, Err(_)=> json_error(StatusCode::INTERNAL_SERVER_ERROR, "fs_error", "cant read file") } }

#[axum::debug_handler]
pub async fn delete_handler(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, Path(file): Path<String>) -> Response { let ip=real_client_ip(&headers, &addr); if file.contains('/') || file.contains("..") || file.contains('\\') { return json_error(StatusCode::BAD_REQUEST, "bad_file", "invalid file name"); } cleanup_expired(&state).await; { let owners=state.owners.read().await; match owners.get(&file) { Some(meta) if meta.owner==ip => {}, _=> return (StatusCode::NOT_FOUND, "not found").into_response(), } } { let mut owners=state.owners.write().await; owners.remove(&file); } let path=state.upload_dir.join(&file); let _=fs::remove_file(&path).await; state.persist_owners().await; (StatusCode::NO_CONTENT, ()).into_response() }

pub async fn file_handler(State(state): State<AppState>, Path(path): Path<String>) -> Response { if path.contains("..") || path.contains('\\') { return (StatusCode::BAD_REQUEST, "bad path").into_response(); } let file_path=state.static_dir.join(&*path); if !file_path.exists() { return (StatusCode::NOT_FOUND, "not found").into_response(); } match fs::read(&file_path).await { Ok(bytes)=>{ let mime=mime_guess::from_path(&file_path).first_or_octet_stream(); ([(axum::http::header::CONTENT_TYPE, mime.as_ref())], bytes).into_response() }, Err(_)=>(StatusCode::INTERNAL_SERVER_ERROR, "cant read file").into_response() } }

pub async fn root_handler(State(state): State<AppState>) -> Response { let index_path=state.static_dir.join("index.html"); if !index_path.exists() { return (StatusCode::NOT_FOUND, "index missing").into_response(); } match fs::read(&index_path).await { Ok(bytes)=>{ let mime=mime_guess::from_path(&index_path).first_or_octet_stream(); ([(axum::http::header::CONTENT_TYPE, mime.as_ref())], bytes).into_response() }, Err(_)=>(StatusCode::INTERNAL_SERVER_ERROR, "cant read index").into_response() } }

pub async fn add_security_headers(req: axum::http::Request<Body>, next: Next) -> Response { let mut resp=next.run(req).await; let h=resp.headers_mut(); if !h.contains_key("X-Content-Type-Options") { h.insert("X-Content-Type-Options", "nosniff".parse().unwrap()); } if !h.contains_key("X-Frame-Options") { h.insert("X-Frame-Options", "DENY".parse().unwrap()); } if !h.contains_key("Referrer-Policy") { h.insert("Referrer-Policy", "no-referrer".parse().unwrap()); } if !h.contains_key("Content-Security-Policy") { h.insert("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:".parse().unwrap()); } if !h.contains_key("Cache-Control") { h.insert("Cache-Control", "private, max-age=0, no-store".parse().unwrap()); } if !h.contains_key("Permissions-Policy") { h.insert("Permissions-Policy", "camera=(), microphone=(), geolocation=(), fullscreen=(), payment=()".parse().unwrap()); } resp }

fn simple_page(message: Option<&str>, files: &[(String,u64)], now: u64) -> String { let mut rows=String::new(); for (name, exp) in files.iter() { let remain = if *exp <= now { Cow::Borrowed("expired") } else { let mut secs=*exp as i64 - now as i64; let d=secs/86400; secs%=86400; let h=secs/3600; secs%=3600; let m=secs/60; secs%=60; let mut parts=Vec::new(); if d>0 { parts.push(format!("{}d", d)); } if h>0 { parts.push(format!("{}h", h)); } if m>0 && parts.len()<2 { parts.push(format!("{}m", m)); } if parts.is_empty() { parts.push(format!("{}s", secs)); } Cow::Owned(parts.join(" ")) }; rows.push_str(&format!("<tr><td style='font-family:monospace'><a href='/f/{0}'>{0}</a></td><td>{1}</td><td><form method='post' action='/simple/delete' style='display:inline'><input type='hidden' name='f' value='{0}'/><button style='background:#942;padding:.25rem .6rem;border:1px solid #b54;color:#fff;border-radius:4px;cursor:pointer;font-size:.65rem'>del</button></form></td></tr>", name, remain)); } let msg_html=message.map(|m| format!("<div style='background:#223038;border:1px solid #33464f;padding:.5rem .7rem;margin:0 0 .8rem;border-radius:6px;font-size:.7rem'>{}</div>", htmlescape::encode_minimal(m))).unwrap_or_default(); format!("<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'/><title>JuiceBox – Simple</title><meta name='viewport' content='width=device-width,initial-scale=1'/><style>body{{background:#0f141b;color:#e8ecf3;font-family:system-ui,Segoe UI,Roboto,sans-serif;margin:0;padding:1.2rem;max-width:880px}}h1{{margin:.2rem 0 .8rem;font-size:1.6rem}}form.upload{{background:#1a2230;padding:1rem 1.1rem 1.2rem;border:1px solid #273242;border-radius:12px;margin:0 0 1.1rem}}fieldset{{border:none;padding:0;margin:0}}label{{font-size:.7rem;letter-spacing:.5px;display:block;margin:0 0 .4rem;opacity:.75}}input[type=file]{{display:block;margin:.4rem 0 .8rem}}select,button,input[type=file]{{font-size:.75rem}}table{{width:100%;border-collapse:collapse;font-size:.65rem}}th,td{{padding:.45rem .5rem;border-bottom:1px solid #273242;text-align:left}}th{{font-weight:600;letter-spacing:.5px;font-size:.6rem;text-transform:uppercase;opacity:.8}}tr:hover td{{background:#1f2935}}.note{{font-size:.58rem;opacity:.55;line-height:1.4;margin-top:.8rem}}.ttl-box{{display:flex;align-items:center;gap:.5rem;margin:.4rem 0 .9rem}}.ttl-box select{{background:#121b24;color:#e8ecf3;border:1px solid #2b394a;padding:.35rem .5rem;border-radius:6px}}button.primary{{background:#ff9800;color:#111;border:1px solid #ffa733;padding:.5rem 1rem;border-radius:8px;cursor:pointer;font-weight:600;letter-spacing:.5px}}button.primary:hover{{filter:brightness(1.1)}}.files-panel{{background:#1a2230;padding:1rem 1.1rem 1.25rem;border:1px solid #273242;border-radius:12px}}</style></head><body><h1>JuiceBox – No&nbsp;Script</h1><p style='margin:0 0 1.1rem;font-size:.8rem;opacity:.75'>Basic uploader for old browsers and disabled JavaScript.</p>{msg_html}<form class='upload' method='post' enctype='multipart/form-data' action='/simple/upload'><fieldset><label>Files</label><input type='file' name='file' multiple required/><div class='ttl-box'><label for='ttl' style='margin:0'>Retention:</label><select name='ttl' id='ttl'><option>1h</option><option>3h</option><option>12h</option><option>1d</option><option selected>3d</option><option>7d</option><option>14d</option></select><span style='font-size:.6rem;opacity:.55'>auto delete</span></div><button class='primary' type='submit'>Upload</button></fieldset></form><div class='files-panel'><h2 style='margin:.1rem 0  .6rem;font-size:.9rem;letter-spacing:.5px;opacity:.8;text-transform:uppercase'>Your Files</h2><table><thead><tr><th>Name</th><th>Expires In</th><th>Delete</th></tr></thead><tbody>{rows}</tbody></table><p class='note'>Files are linked to your IP. They expire automatically. Keep page for reference or bookmark links.</p></div><p class='note'>Return to <a href='/' style='color:#ff9800'>JS interface</a>.</p></body></html>") }

pub async fn simple_root(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, Query(q): Query<SimpleQuery>) -> Response { reload_metadata_if_changed(&state).await; let ip=real_client_ip(&headers, &addr); verify_user_entries(&state, &ip).await; cleanup_expired(&state).await; crate::state::check_storage_integrity(&state).await; let now=now_secs(); let owners=state.owners.read().await; let mut my_files: Vec<(String,u64)>=owners.iter().filter(|(_,m)| m.owner==ip).map(|(n,m)|(n.clone(), m.expires)).collect(); my_files.sort_by(|a,b| a.0.cmp(&b.0)); let html=simple_page(q.m.as_deref(), &my_files, now); (StatusCode::OK, [(CACHE_CONTROL, HeaderValue::from_static("no-store")), (CONTENT_TYPE, HeaderValue::from_static("text/html; charset=utf-8"))], html).into_response() }

#[axum::debug_handler]
pub async fn simple_upload(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, mut multipart: Multipart) -> Response { let ip=real_client_ip(&headers, &addr); let mut saved=Vec::new(); let mut ttl_choice=None; while let Ok(Some(field))=multipart.next_field().await { if let Some(name)=field.name() { if name=="ttl" { if let Ok(v)=field.text().await { ttl_choice=Some(v); } continue; } } let mut field=field; if let Some(orig_filename)=field.file_name() { if is_forbidden_extension(orig_filename) { return json_error(StatusCode::BAD_REQUEST, "forbidden_type", "file type not allowed"); } let new_name=make_storage_name(Some(orig_filename)); let path=state.upload_dir.join(&new_name); let mut file=match fs::File::create(&path).await { Ok(f)=>f, Err(_)=> return json_error(StatusCode::INTERNAL_SERVER_ERROR, "fs_error", "failed create") }; let mut written=0u64; let mut aborted=false; loop { match field.chunk().await { Ok(opt)=>{ if let Some(chunk)=opt { written += chunk.len() as u64; if written > MAX_FILE_BYTES { let _=fs::remove_file(&path).await; let msg=urlencoding::encode("File exceeds 500MB limit"); let loc=format!("/simple?m={}", msg); let hv=HeaderValue::from_str(&loc).unwrap(); return (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response(); } if file.write_all(&chunk).await.is_err() { aborted=true; break; } } else { break; } }, Err(_)=>{ aborted=true; let _=fs::remove_file(&path).await; break; } } } if aborted || written==0 { let _=fs::remove_file(&path).await; continue; } let ttl_code=ttl_choice.clone().unwrap_or_else(||"3d".into()); let expires=now_secs()+ttl_to_duration(&ttl_code).as_secs(); { let mut owners=state.owners.write().await; owners.insert(new_name.clone(), FileMeta { owner: ip.clone(), expires }); } state.persist_owners().await; saved.push(new_name); } }
    if saved.is_empty() { return (StatusCode::BAD_REQUEST, "no files").into_response(); }
    spawn_integrity_check(state.clone());
    let msg=format!("Uploaded {} file(s)", saved.len()); let redirect= if state.production { format!("https://{}/simple?m={}", PROD_HOST, urlencoding::encode(&msg)) } else { format!("/simple?m={}", urlencoding::encode(&msg)) }; let hv=HeaderValue::from_str(&redirect).unwrap(); (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response()
}

#[axum::debug_handler]
pub async fn simple_delete(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, Form(frm): Form<SimpleDeleteForm>) -> Response { let ip=real_client_ip(&headers, &addr); let target=frm.f; let owned={ let owners=state.owners.read().await; owners.get(&target).map(|m| m.owner.clone()) }; if owned.is_some() && owned.unwrap()==ip { { let mut owners=state.owners.write().await; owners.remove(&target); } let _=fs::remove_file(state.upload_dir.join(&target)).await; state.persist_owners().await; let hv=HeaderValue::from_static("/simple?m=Deleted"); return (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response(); } let hv=HeaderValue::from_static("/simple?m=Not+found"); (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response() }

pub async fn faq_handler(State(state): State<AppState>) -> Response { let path=state.static_dir.join("faq.html"); if !path.exists() { return (StatusCode::NOT_FOUND, "faq missing").into_response(); } match fs::read(&path).await { Ok(bytes)=>([(axum::http::header::CONTENT_TYPE, "text/html; charset=utf-8")], bytes).into_response(), Err(_)=>(StatusCode::INTERNAL_SERVER_ERROR, "cant read faq").into_response() } }
pub async fn terms_handler(State(state): State<AppState>) -> Response { let path=state.static_dir.join("terms.html"); if !path.exists() { return (StatusCode::NOT_FOUND, "terms missing").into_response(); } match fs::read(&path).await { Ok(bytes)=>([(axum::http::header::CONTENT_TYPE, "text/html; charset=utf-8")], bytes).into_response(), Err(_)=>(StatusCode::INTERNAL_SERVER_ERROR, "cant read terms").into_response() } }

pub async fn thumbnail_handler(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>) -> Response { if !addr.ip().is_loopback() { return (StatusCode::NOT_FOUND, "not found").into_response(); } let path=state.static_dir.join("thumbnail.html"); if !path.exists() { return (StatusCode::NOT_FOUND, "thumbnail missing").into_response(); } match fs::read(&path).await { Ok(bytes)=>([(axum::http::header::CONTENT_TYPE, "text/html; charset=utf-8")], bytes).into_response(), Err(_)=>(StatusCode::INTERNAL_SERVER_ERROR, "cant read thumbnail").into_response() } }

pub async fn debug_ip_handler(ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap) -> Response { let cf=headers.get("CF-Connecting-IP").and_then(|v| v.to_str().ok()).unwrap_or("-"); let xff=headers.get("X-Forwarded-For").and_then(|v| v.to_str().ok()).unwrap_or("-"); let edge=addr.ip().to_string(); let body=serde_json::json!({"cf":cf, "xff":xff, "edge":edge}); (StatusCode::OK, Json(body)).into_response() }

fn inject_report_message(html: String, msg: &str) -> String { let banner=format!("<div class='report-msg' style=\"background:#223038;border:1px solid #33464f;padding:.55rem .75rem;margin:0 0 1rem;border-radius:8px;font-size:.7rem;letter-spacing:.4px;\">{}</div>", htmlescape::encode_minimal(msg)); if let Some(pos)=html.find("<body") { if let Some(close)=html[pos..].find('>') { return html[..pos+close+1].to_string()+ &banner + &html[pos+close+1..]; } } banner + &html }

pub async fn report_page_handler(State(state): State<AppState>, Query(q): Query<HashMap<String,String>>) -> Response { let path=state.static_dir.join("report.html"); let mut html= if path.exists() { match fs::read_to_string(&path).await { Ok(s)=>s, Err(_)=>"<!DOCTYPE html><html><body><h1>Report</h1><p>Form unavailable.</p></body></html>".into() } } else { "<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'/><title>Report Content – JuiceBox</title><meta name='viewport' content='width=device-width,initial-scale=1'/><style>body{font-family:system-ui,Segoe UI,Roboto,sans-serif;background:#0f141b;color:#e8ecf3;margin:0;padding:1.3rem;max-width:680px}h1{margin:.2rem 0 1rem;font-size:1.5rem}form{background:#1a2230;padding:1rem 1.1rem 1.2rem;border:1px solid #273242;border-radius:12px;display:flex;flex-direction:column;gap:.75rem}label span.req{color:#ff5252}input[type=text],select,textarea{background:#121b24;color:#e8ecf3;border:1px solid #2b394a;border-radius:6px;padding:.55rem .65rem;font-size:.75rem;font-family:inherit}textarea{min-height:140px;resize:vertical}button{background:#ff9800;color:#111;border:1px solid #ffa733;padding:.6rem 1.1rem;border-radius:8px;cursor:pointer;font-weight:600;letter-spacing:.5px;font-size:.75rem}button:hover{filter:brightness(1.08)}p.note{font-size:.6rem;opacity:.6;line-height:1.4}.report-msg{background:#223038;border:1px solid #33464f;padding:.55rem .75rem;margin:0 0 1rem;border-radius:8px;font-size:.7rem}</style></head><body><h1>Report Content</h1><form method='post' action='/report'><label>File ID <span class='req'>*</span><input type='text' name='file' maxlength='80' required placeholder='e.g. AbCdEf1234567890'/></label><label>Reason <span class='req'>*</span><select name='reason' required><option value='spam'>Spam / advertising</option><option value='malware'>Malware / executable abuse</option><option value='copyright'>Copyright infringement</option><option value='personal'>Personal data / doxxing</option><option value='harassment'>Harassment / hate</option><option value='other'>Other</option></select></label><label>Details (optional)<textarea name='details' maxlength='1000' placeholder='Provide context (no extra personal data).'></textarea></label><button type='submit'>Submit Report</button><p class='note'>Your IP is stored with the report for abuse review. We do not guarantee removal.</p><p class='note'><a href='/'>Home</a></p></form></body></html>".into() }; if let Some(m)=q.get("m") { html=inject_report_message(html, m); } (StatusCode::OK, [(CONTENT_TYPE, HeaderValue::from_static("text/html; charset=utf-8")), (CACHE_CONTROL, HeaderValue::from_static("no-store"))], html).into_response() }

#[axum::debug_handler]
pub async fn report_submit_handler(State(state): State<AppState>, ConnectInfo(addr): ConnectInfo<ClientAddr>, headers: HeaderMap, Form(frm): Form<ReportForm>) -> Response { let ip=real_client_ip(&headers, &addr); let mut file=frm.file.trim().to_string(); if file.starts_with("f/") { file=file[2..].to_string(); } if file.is_empty() || file.len()>80 || file.contains('/') || file.contains("..") || file.contains('\\') { let hv=HeaderValue::from_static("/report?m=Invalid+file+id"); return (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response(); } let reason=frm.reason.trim(); let allowed=["spam","malware","copyright","personal","harassment","other"]; if !allowed.contains(&reason) { let hv=HeaderValue::from_static("/report?m=Bad+reason"); return (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response(); } let details=frm.details.unwrap_or_default(); if state.upload_dir.join(&file).exists() { let record=ReportRecord { file:file.clone(), reason:reason.to_string(), details:details.chars().take(1000).collect(), ip, time: now_secs() }; { let mut reports=state.reports.write().await; reports.push(record); } state.persist_reports().await; } let hv=HeaderValue::from_static("/report?m=Submitted"); (StatusCode::SEE_OTHER, [(axum::http::header::LOCATION, hv)]).into_response() }

// Host enforcement middleware
pub async fn enforce_host(req: axum::http::Request<Body>, next: Next) -> Response { if let Some(host)=req.headers().get(axum::http::header::HOST).and_then(|h| h.to_str().ok()) { if host != PROD_HOST && host != "localhost:1200" && host != "127.0.0.1:1200" && host != "0.0.0.0:1200" { let uri=req.uri(); let pq=match uri.path_and_query() { Some(pq)=>pq.as_str(), None=>uri.path() }; let loc=format!("https://{}{}", PROD_HOST, pq); return (StatusCode::PERMANENT_REDIRECT, [(axum::http::header::LOCATION, HeaderValue::from_str(&loc).unwrap())]).into_response(); } }
    next.run(req).await }

// Build router (used by main)
pub fn build_router(state: AppState) -> Router { Router::new()
        .route("/", get(root_handler))
        .route("/upload", post(upload_handler))
        .route("/mine", get(list_handler))
        .route("/d/{file}", delete(delete_handler))
        .route("/f/{file}", get(fetch_file_handler))
        .route("/simple", get(simple_root))
        .route("/simple/upload", post(simple_upload))
        .route("/simple/delete", post(simple_delete))
        .route("/thumbnail", get(thumbnail_handler))
        .route("/faq", get(faq_handler))
        .route("/terms", get(terms_handler))
        .route("/report", get(report_page_handler).post(report_submit_handler))
        .route("/debug-ip", get(debug_ip_handler))
        .route("/healthz", get(|| async { "ok" }))
        .route("/readyz", get(|State(state): State<AppState>| async move { if state.metadata_path.parent().map(|p| p.exists()).unwrap_or(false) { "ready".into_response() } else { json_error(StatusCode::SERVICE_UNAVAILABLE, "not_ready", "storage not ready") } }))
        .route("/{*path}", get(file_handler))
        .with_state(state)
}
